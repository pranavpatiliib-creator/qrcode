<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>College Food Distribution Scanner</title>
    <style>
      :root {
        --bg: #0f172a;
        --panel: #111827;
        --text: #e5e7eb;
        --accent: #22c55e;
        --warn: #ef4444;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(145deg, #020617 0%, #0b1120 60%, #172554 100%);
        color: var(--text);
        display: grid;
        place-items: center;
        padding: 16px;
      }

      .app {
        width: 100%;
        max-width: 540px;
        background: rgba(17, 24, 39, 0.95);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 16px;
        padding: 16px;
      }

      h1 {
        margin-top: 0;
        font-size: 1.25rem;
      }

      #reader {
        width: 100%;
        min-height: 240px;
        border-radius: 12px;
        overflow: hidden;
        background: #000;
      }

      #reader video {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 12px;
      }

      .hidden {
        display: none;
      }

      .login-panel {
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 12px;
        padding: 12px;
        background: rgba(15, 23, 42, 0.7);
        margin-bottom: 10px;
      }

      .login-panel h2 {
        margin: 0 0 10px;
        font-size: 1rem;
      }

      #loginError {
        margin-top: 8px;
        min-height: 20px;
      }

      button,
      input {
        width: 100%;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        padding: 10px;
        font-size: 1rem;
      }

      button {
        background: #1e293b;
        color: var(--text);
        cursor: pointer;
      }

      input {
        background: #0f172a;
        color: var(--text);
      }

      #status {
        margin-top: 12px;
        padding: 10px;
        border-radius: 10px;
        background: #0f172a;
      }

      #lastSuccess,
      #successCount {
        margin-top: 8px;
        padding: 8px 10px;
        border-radius: 10px;
        background: #0f172a;
      }

      #successFlash {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        opacity: 0;
        transform: scale(0.75);
        transition: opacity 0.14s ease, transform 0.14s ease;
        background: radial-gradient(circle at center, rgba(34, 197, 94, 0.16) 0%, rgba(15, 23, 42, 0) 65%);
        z-index: 9999;
      }

      #successFlash.show {
        opacity: 1;
        transform: scale(1);
      }

      #successFlash .tick {
        font-size: clamp(90px, 26vw, 170px);
        line-height: 1;
        font-weight: 700;
        color: #22c55e;
        text-shadow: 0 0 20px rgba(34, 197, 94, 0.45);
      }

      #failFlash {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        opacity: 0;
        transform: scale(0.75);
        transition: opacity 0.14s ease, transform 0.14s ease;
        background: radial-gradient(circle at center, rgba(239, 68, 68, 0.18) 0%, rgba(15, 23, 42, 0) 65%);
        z-index: 9999;
      }

      #failFlash.show {
        opacity: 1;
        transform: scale(1);
      }

      #failFlash .cross {
        font-size: clamp(90px, 26vw, 170px);
        line-height: 1;
        font-weight: 700;
        color: #ef4444;
        text-shadow: 0 0 20px rgba(239, 68, 68, 0.45);
      }

      .ok {
        color: var(--accent);
      }

      .bad {
        color: var(--warn);
      }

      .small {
        font-size: 0.85rem;
        color: #9ca3af;
      }

      @media (max-width: 480px) {
        #reader {
          min-height: 320px;
        }

        .controls {
          grid-template-columns: 1fr;
        }
      }
    </style>
    <script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"></script>
  </head>
  <body>
    <main class="app">
      <h1>College Food Distribution Scanner</h1>
      <div id="successFlash" aria-hidden="true">
        <div class="tick">&#10003;</div>
      </div>
      <div id="failFlash" aria-hidden="true">
        <div class="cross">&#10007;</div>
      </div>
      <section id="loginPanel" class="login-panel">
        <h2>Operator Login</h2>
        <div class="controls">
          <input id="loginUserId" type="text" placeholder="User ID" autocomplete="username" value="safe" />
          <input id="loginPassword" type="password" placeholder="Password" autocomplete="current-password" />
        </div>
        <div class="controls">
          <button id="loginBtn" type="button">Login</button>
        </div>
        <div id="loginError" class="small bad"></div>
      </section>

      <section id="scannerSection" class="hidden">
        <div id="reader"></div>

        <p class="small">Camera fallback: manually type barcode/ID below if camera is unavailable.</p>
        <div class="controls">
          <input id="manualId" type="text" placeholder="Enter ID manually" autocomplete="off" />
          <button id="manualSubmit" type="button">Submit ID</button>
        </div>

        <div id="status">Status: Initializing scanner...</div>
        <div id="lastSuccess">Last successful scan: none</div>
        <div id="successCount">Successful scans: 0</div>
        <p class="small">Offline scans are cached and synced when internet returns.</p>
      </section>
    </main>

    <script>
      // Update this if your backend is hosted elsewhere.
      const API_BASE_URL = window.location.origin;
      const AUTH_LOGIN_ENDPOINT = `${API_BASE_URL}/api/auth/login`;
      const SCAN_ENDPOINT = `${API_BASE_URL}/api/scan`;
      const OFFLINE_QUEUE_KEY = "offline_scan_queue_v1";
      const AUTH_TOKEN_KEY = "scanner_auth_token_v1";
      const SCAN_COOLDOWN_MS = 350;
      const FAST_SCAN_FPS_MOBILE = 20;
      const FAST_SCAN_FPS_DESKTOP = 24;
      const REQUIRED_STABLE_DETECTIONS = 2;
      const STABLE_WINDOW_MS = 550;
      const MIN_BARCODE_LENGTH = 5;
      const MAX_BARCODE_LENGTH = 40;

      const statusEl = document.getElementById("status");
      const lastSuccessEl = document.getElementById("lastSuccess");
      const successCountEl = document.getElementById("successCount");
      const successFlashEl = document.getElementById("successFlash");
      const failFlashEl = document.getElementById("failFlash");
      const loginPanelEl = document.getElementById("loginPanel");
      const scannerSectionEl = document.getElementById("scannerSection");
      const loginUserIdEl = document.getElementById("loginUserId");
      const loginPasswordEl = document.getElementById("loginPassword");
      const loginBtnEl = document.getElementById("loginBtn");
      const loginErrorEl = document.getElementById("loginError");
      const manualIdEl = document.getElementById("manualId");
      const manualSubmitBtn = document.getElementById("manualSubmit");

      let scanner = null;
      let active = false;
      let authToken = sessionStorage.getItem(AUTH_TOKEN_KEY) || "";
      let lastProcessed = "";
      let lastProcessedAt = 0;
      let lastDecodeErrorAt = 0;
      let successfulScanCount = 0;
      const inFlightIds = new Set();
      let pendingDecoded = "";
      let pendingCount = 0;
      let pendingStartedAt = 0;
      let successFlashTimer = null;
      let failFlashTimer = null;
      let audioContext = null;

      function getBarcodeFormats() {
        if (typeof Html5QrcodeSupportedFormats === "undefined") {
          return undefined;
        }

        const f = Html5QrcodeSupportedFormats;
        return [
          f.CODE_128,
          f.CODE_39,
          f.EAN_13,
          f.EAN_8,
          f.ITF,
          f.UPC_A,
          f.UPC_E
        ].filter(Boolean);
      }

      function setStatus(message, type) {
        statusEl.className = type === "ok" ? "ok" : type === "bad" ? "bad" : "";
        statusEl.textContent = `Status: ${message}`;
      }

      function setLoginState(isLoggedIn) {
        if (isLoggedIn) {
          loginPanelEl.classList.add("hidden");
          scannerSectionEl.classList.remove("hidden");
          return;
        }

        loginPanelEl.classList.remove("hidden");
        scannerSectionEl.classList.add("hidden");
      }

      function clearAuth() {
        authToken = "";
        sessionStorage.removeItem(AUTH_TOKEN_KEY);
      }

      function getAuthHeaders(baseHeaders = {}) {
        if (!authToken) return baseHeaders;
        return { ...baseHeaders, Authorization: `Bearer ${authToken}` };
      }

      async function stopScannerSilently() {
        if (!scanner || !active) return;
        try {
          await scanner.stop();
          await scanner.clear();
        } catch {}
        active = false;
      }

      async function handleAuthRequired(message) {
        await stopScannerSilently();
        clearAuth();
        loginErrorEl.textContent = message || "Login required";
        setLoginState(false);
        setStatus("login required", "bad");
      }

      async function loginOperator() {
        const userId = loginUserIdEl.value.trim();
        const password = loginPasswordEl.value;

        if (!userId || !password) {
          loginErrorEl.textContent = "Enter user ID and password";
          return;
        }

        loginBtnEl.disabled = true;
        loginErrorEl.textContent = "";

        try {
          const response = await fetch(AUTH_LOGIN_ENDPOINT, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ userId, password })
          });

          let data = {};
          try {
            data = await response.json();
          } catch {
            data = {};
          }

          if (!response.ok || !data?.data?.token) {
            loginErrorEl.textContent = data.message || "Invalid credentials";
            return;
          }

          authToken = data.data.token;
          sessionStorage.setItem(AUTH_TOKEN_KEY, authToken);
          loginPasswordEl.value = "";
          setLoginState(true);
          setStatus("login successful, starting scanner...", "ok");
          await syncOfflineQueue();
          await startScanner();
        } catch {
          loginErrorEl.textContent = "Unable to login. Check connection.";
        } finally {
          loginBtnEl.disabled = false;
        }
      }

      async function primeAudioContext() {
        try {
          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) return;
          if (!audioContext) {
            audioContext = new AudioContextClass();
          }
          if (audioContext.state === "suspended") {
            await audioContext.resume();
          }
        } catch {}
      }

      function playSuccessTone() {
        try {
          const AudioContextClass = window.AudioContext || window.webkitAudioContext;
          if (!AudioContextClass) return;
          if (!audioContext) {
            audioContext = new AudioContextClass();
          }

          if (audioContext.state === "suspended") {
            return;
          }

          const now = audioContext.currentTime;
          const oscillator = audioContext.createOscillator();
          const gain = audioContext.createGain();

          oscillator.type = "triangle";
          oscillator.frequency.setValueAtTime(880, now);
          oscillator.frequency.exponentialRampToValueAtTime(1320, now + 0.09);
          gain.gain.setValueAtTime(0.0001, now);
          gain.gain.exponentialRampToValueAtTime(0.2, now + 0.02);
          gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.18);

          oscillator.connect(gain);
          gain.connect(audioContext.destination);
          oscillator.start(now);
          oscillator.stop(now + 0.2);
        } catch {}
      }

      function showSuccessFlash() {
        if (!successFlashEl) return;
        successFlashEl.classList.add("show");
        if (successFlashTimer) {
          clearTimeout(successFlashTimer);
        }
        successFlashTimer = setTimeout(() => {
          successFlashEl.classList.remove("show");
          successFlashTimer = null;
        }, 650);
      }

      function showFailFlash() {
        if (!failFlashEl) return;
        failFlashEl.classList.add("show");
        if (failFlashTimer) {
          clearTimeout(failFlashTimer);
        }
        failFlashTimer = setTimeout(() => {
          failFlashEl.classList.remove("show");
          failFlashTimer = null;
        }, 650);
      }

      function markRejectedScan() {
        showFailFlash();
      }

      function normalizeDecodedValue(decodedText) {
        return String(decodedText || "")
          .trim()
          .replace(/\s+/g, "");
      }

      function isPlausibleBarcodeValue(value) {
        if (!value) return false;
        if (value.length < MIN_BARCODE_LENGTH || value.length > MAX_BARCODE_LENGTH) return false;
        if (/^(.)\1+$/.test(value)) return false;
        return true;
      }

      function getStableDecodedValue(decodedText) {
        const value = normalizeDecodedValue(decodedText);
        if (!isPlausibleBarcodeValue(value)) {
          return null;
        }

        const now = Date.now();
        if (value === pendingDecoded && now - pendingStartedAt <= STABLE_WINDOW_MS) {
          pendingCount += 1;
        } else {
          pendingDecoded = value;
          pendingCount = 1;
          pendingStartedAt = now;
        }

        if (pendingCount < REQUIRED_STABLE_DETECTIONS) {
          setStatus(`detected ${value}, hold steady...`, "");
          return null;
        }

        pendingDecoded = "";
        pendingCount = 0;
        pendingStartedAt = 0;
        return value;
      }

      function markSuccessfulScan(id) {
        successfulScanCount += 1;
        lastSuccessEl.textContent = `Last successful scan: ${id}`;
        successCountEl.textContent = `Successful scans: ${successfulScanCount}`;
        showSuccessFlash();
        playSuccessTone();
        if (navigator.vibrate) {
          navigator.vibrate(60);
        }
      }

      function hasSecureCameraContext() {
        return window.isSecureContext || window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1";
      }

      function pickBestCameraId(cameras) {
        if (!cameras || cameras.length === 0) return null;
        const preferred = ["back", "rear", "environment", "world"];
        const match = cameras.find((cam) => preferred.some((word) => (cam.label || "").toLowerCase().includes(word)));
        return (match || cameras[0]).id;
      }

      function isMobileDevice() {
        return window.matchMedia("(max-width: 768px)").matches || navigator.maxTouchPoints > 1;
      }

      function ensureInlineVideoPlayback() {
        const video = document.querySelector("#reader video");
        if (!video) return;
        video.setAttribute("playsinline", "true");
        video.setAttribute("muted", "true");
        video.playsInline = true;
        video.muted = true;
      }

      function buildCameraOptions(cameras) {
        const options = [];
        const preferredCameraId = pickBestCameraId(cameras);

        if (preferredCameraId) {
          options.push({
            deviceId: { exact: preferredCameraId },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          });
        }

        options.push({
          facingMode: { ideal: "environment" },
          width: { ideal: 1280 },
          height: { ideal: 720 },
          advanced: [{ focusMode: "continuous" }]
        });
        options.push({
          facingMode: { ideal: "environment" },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        });
        options.push({ facingMode: "environment" });
        options.push({ facingMode: { ideal: "user" } });
        options.push({ facingMode: "user" });

        return options;
      }

      function getScannerConfig() {
        const config = {
          fps: isMobileDevice() ? FAST_SCAN_FPS_MOBILE : FAST_SCAN_FPS_DESKTOP,
          disableFlip: true,
          rememberLastUsedCamera: true,
          formatsToSupport: getBarcodeFormats(),
          experimentalFeatures: {
            useBarCodeDetectorIfSupported: true
          }
        };

        config.qrbox = (viewfinderWidth, viewfinderHeight) => {
          const isMobile = isMobileDevice();

          // Wide but not full-width region balances accuracy and speed for 1D barcodes.
          const maxWidth = Math.max(220, viewfinderWidth - 14);
          const width = Math.min(maxWidth, Math.floor(viewfinderWidth * (isMobile ? 0.92 : 0.84)));
          const height = Math.max(68, Math.floor(width * (isMobile ? 0.22 : 0.2)));

          if (isMobile) {
            return { width, height };
          }

          return { width, height };
        };

        if (typeof Html5QrcodeScanType !== "undefined") {
          config.supportedScanTypes = [Html5QrcodeScanType.SCAN_TYPE_CAMERA];
        }

        return config;
      }

      function readOfflineQueue() {
        try {
          return JSON.parse(localStorage.getItem(OFFLINE_QUEUE_KEY) || "[]");
        } catch {
          return [];
        }
      }

      function writeOfflineQueue(queue) {
        localStorage.setItem(OFFLINE_QUEUE_KEY, JSON.stringify(queue));
      }

      function queueOfflineScan(id, source) {
        const queue = readOfflineQueue();
        queue.push({ id, source, queuedAt: new Date().toISOString() });
        writeOfflineQueue(queue);
      }

      async function submitScan(id, source) {
        const payload = { id, source };
        const normalizedId = (id || "").trim();
        if (!normalizedId) return;

        if (!authToken) {
          await handleAuthRequired("Please login to continue");
          return;
        }

        if (inFlightIds.has(normalizedId)) {
          return;
        }

        if (!navigator.onLine) {
          queueOfflineScan(normalizedId, source);
          setStatus(`offline cached: ${normalizedId}`, "bad");
          return;
        }

        inFlightIds.add(normalizedId);
        try {
          const response = await fetch(SCAN_ENDPOINT, {
            method: "POST",
            headers: getAuthHeaders({ "Content-Type": "application/json" }),
            body: JSON.stringify(payload),
            cache: "no-store"
          });

          let data = {};
          try {
            data = await response.json();
          } catch {
            data = {};
          }

          if (response.status === 401) {
            await handleAuthRequired("Session expired. Please login again.");
            return;
          }

          if (!response.ok) {
            setStatus(data.message || "request failed", "bad");
            markRejectedScan();
            return;
          }

          const displayId = data && data.data && data.data.id ? data.data.id : normalizedId;

          if (data.message === "allowed") {
            setStatus(`${displayId} -> allowed`, "ok");
            markSuccessfulScan(displayId);
          } else {
            setStatus(`${displayId} -> already taken`, "bad");
            markRejectedScan();
          }
        } catch {
          queueOfflineScan(normalizedId, source);
          setStatus(`network issue, cached: ${normalizedId}`, "bad");
        } finally {
          inFlightIds.delete(normalizedId);
        }
      }

      async function syncOfflineQueue() {
        if (!navigator.onLine || !authToken) return;

        const queue = readOfflineQueue();
        if (!queue.length) return;

        const remaining = [];

        for (let index = 0; index < queue.length; index += 1) {
          const item = queue[index];
          try {
            const response = await fetch(SCAN_ENDPOINT, {
              method: "POST",
              headers: getAuthHeaders({ "Content-Type": "application/json" }),
              body: JSON.stringify({ id: item.id, source: "sync" })
            });

            if (response.status === 401) {
              remaining.push(item, ...queue.slice(index + 1));
              await handleAuthRequired("Session expired. Please login again.");
              break;
            }

            if (!response.ok) {
              remaining.push(item);
            }
          } catch {
            remaining.push(item);
          }
        }

        writeOfflineQueue(remaining);
        if (remaining.length === 0) {
          setStatus("offline queue synced", "ok");
        }
      }

      async function startScanner() {
        if (active) return;

        if (!authToken) {
          await handleAuthRequired("Please login to start scanner");
          return;
        }

        if (typeof Html5Qrcode === "undefined") {
          setStatus("scanner library failed to load. check internet/CDN access", "bad");
          return;
        }

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
          setStatus("camera API not supported on this browser", "bad");
          return;
        }

        if (!hasSecureCameraContext()) {
          setStatus("camera needs HTTPS (or localhost) to work", "bad");
          return;
        }

        try {
          if (scanner && !active) {
            try {
              await scanner.clear();
            } catch {}
          }

          scanner = new Html5Qrcode("reader");
          const config = getScannerConfig();
          const cameras = await Html5Qrcode.getCameras().catch(() => []);
          const cameraOptions = buildCameraOptions(cameras);

          let startError = null;
          for (const cameraOption of cameraOptions) {
            try {
              await scanner.start(
                cameraOption,
                config,
                (decodedText) => {
                  const stableValue = getStableDecodedValue(decodedText);
                  if (!stableValue) {
                    return;
                  }

                  // Prevent rapid duplicate submits from the same continuous frame.
                  const now = Date.now();
                  if (stableValue === lastProcessed && now - lastProcessedAt < SCAN_COOLDOWN_MS) {
                    return;
                  }
                  if (inFlightIds.has(stableValue)) {
                    return;
                  }
                  lastProcessed = stableValue;
                  lastProcessedAt = now;
                  setStatus(`detected ${stableValue}, validating...`, "");
                  // Keep decode loop fast by not blocking on network.
                  void submitScan(stableValue, "camera");
                },
                () => {
                  const now = Date.now();
                  // Keep UI calm and avoid flashing every frame error.
                  if (now - lastDecodeErrorAt > 3500) {
                    lastDecodeErrorAt = now;
                    setStatus("camera active - keep barcode horizontal inside frame", "");
                  }
                }
              );

              ensureInlineVideoPlayback();
              active = true;
              setStatus("auto barcode detection active", "ok");
              return;
            } catch (err) {
              startError = err;
            }
          }

          throw startError || new Error("No camera could be started");
        } catch (err) {
          console.error("Scanner start failed:", err);
          const errorText = err && err.message ? err.message : "camera unavailable/blocked";
          setStatus(`${errorText}. allow permission or use manual input`, "bad");
        }
      }

      manualSubmitBtn.addEventListener("click", async () => {
        if (!authToken) {
          await handleAuthRequired("Please login to continue");
          return;
        }
        const id = manualIdEl.value.trim();
        if (!id) {
          setStatus("enter an ID first", "bad");
          return;
        }
        await submitScan(id, "manual");
        manualIdEl.value = "";
      });

      loginBtnEl.addEventListener("click", loginOperator);
      loginPasswordEl.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          void loginOperator();
        }
      });

      window.addEventListener("online", syncOfflineQueue);
      window.addEventListener(
        "pointerdown",
        () => {
          void primeAudioContext();
        },
        { once: true }
      );
      window.addEventListener("load", async () => {
        await primeAudioContext();
        if (!authToken) {
          setLoginState(false);
          setStatus("please login to start scanner", "");
          return;
        }
        setLoginState(true);
        await syncOfflineQueue();
        await startScanner();
      });
    </script>
  </body>
</html>
